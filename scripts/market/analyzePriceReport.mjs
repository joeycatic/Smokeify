/**
 * Analyze the competitor price report generated by shopsPriceStats.mjs.
 * Reads shops-price-report.json and prints a ranked comparison of your prices
 * vs. competitor averages.
 *
 * Usage:
 *   node scripts/market/analyzePriceReport.mjs [options]
 *
 * Options:
 *   --input <path>        JSON report path (default: scripts/market/shops-price-report.json)
 *   --min-shops <n>       Min number of sampled shops required to include a product (default: 1)
 *   --threshold <pct>     Highlight products where diff exceeds this % (default: 10)
 *   --sort price|diff     Sort output by your price or by % diff from avg (default: diff)
 *   --only-above          Only show products where you are above competitor avg (overpriced)
 *   --only-below          Only show products where you are below competitor avg (underpriced)
 *   --output-csv <path>   Write analysis to CSV (default: scripts/market/price-analysis.csv)
 *   --no-csv              Skip CSV output
 */

import fs from "node:fs/promises";

const args = process.argv.slice(2);
const hasFlag = (f) => args.includes(f);
const flagValue = (f) => { const i = args.indexOf(f); return i !== -1 ? args[i + 1] ?? null : null; };

const INPUT = flagValue("--input") ?? "scripts/market/shops-price-report.json";
const MIN_SHOPS = Math.max(1, Number(flagValue("--min-shops") ?? 1));
const THRESHOLD_PCT = Math.max(0, Number(flagValue("--threshold") ?? 10));
const SORT_BY = flagValue("--sort") ?? "diff"; // "price" or "diff"
const ONLY_ABOVE = hasFlag("--only-above");
const ONLY_BELOW = hasFlag("--only-below");
const OUTPUT_CSV = hasFlag("--no-csv") ? null : (flagValue("--output-csv") ?? "scripts/market/price-analysis.csv");

const fmt = (n) => typeof n === "number" ? `€${n.toFixed(2)}` : "-";
const fmtPct = (n) => typeof n === "number" ? `${n > 0 ? "+" : ""}${n.toFixed(1)}%` : "-";

const toCsvLine = (values) =>
  values.map((v) => `"${String(v ?? "").replace(/"/g, '""')}"`).join(",");

const run = async () => {
  let raw;
  try {
    raw = await fs.readFile(INPUT, "utf8");
  } catch {
    console.error(`[analyze] Cannot read report: ${INPUT}`);
    console.error(`[analyze] Run shopsPriceStats.mjs first to generate it.`);
    process.exitCode = 1;
    return;
  }

  const report = JSON.parse(raw);
  const generatedAt = report.generatedAt ?? "unknown";
  const allResults = Array.isArray(report.results) ? report.results : [];

  // Only include products with price data and enough shop coverage
  const withData = allResults.filter(
    (r) =>
      r.status === "ok" &&
      typeof r.referencePrice === "number" &&
      typeof r.average === "number" &&
      (r.sampledShops ?? 0) >= MIN_SHOPS
  );

  if (!withData.length) {
    console.log(`[analyze] No products with competitor data found in ${INPUT}.`);
    console.log(`[analyze] Total in report: ${allResults.length}, with data: ${withData.length}`);
    return;
  }

  // Compute analysis per product
  const rows = withData.map((r) => {
    const yourPrice = r.referencePrice;
    const competitorAvg = r.average;
    const diffEur = yourPrice - competitorAvg;
    const diffPct = (diffEur / competitorAvg) * 100;
    return {
      title: r.title,
      manufacturer: r.manufacturer ?? "",
      handle: r.handle,
      yourPrice,
      competitorLow: r.lowest,
      competitorAvg,
      competitorHigh: r.highest,
      diffEur,       // positive = you are more expensive
      diffPct,       // positive = you are more expensive
      sampledShops: r.sampledShops,
      samples: r.samples,
    };
  });

  // Filter
  const filtered = rows.filter((r) => {
    if (ONLY_ABOVE && r.diffPct <= 0) return false;
    if (ONLY_BELOW && r.diffPct >= 0) return false;
    return true;
  });

  // Sort
  const sorted = [...filtered].sort((a, b) =>
    SORT_BY === "price"
      ? b.yourPrice - a.yourPrice
      : b.diffPct - a.diffPct
  );

  // Split into above / below / on-par
  const above = sorted.filter((r) => r.diffPct > THRESHOLD_PCT);
  const below = sorted.filter((r) => r.diffPct < -THRESHOLD_PCT);
  const near = sorted.filter((r) => Math.abs(r.diffPct) <= THRESHOLD_PCT);

  const COL_TITLE = 38;
  const COL_PRICE = 10;
  const COL_AVG   = 10;
  const COL_DIFF  = 10;
  const COL_SHOPS = 6;

  const pad = (s, n) => String(s ?? "").padEnd(n).slice(0, n);
  const padL = (s, n) => String(s ?? "").padStart(n).slice(-n);

  const header = [
    pad("Product", COL_TITLE),
    padL("Your €", COL_PRICE),
    padL("Mkt Avg", COL_AVG),
    padL("Mkt Low", COL_AVG),
    padL("Diff €", COL_DIFF),
    padL("Diff %", COL_DIFF),
    padL("Shops", COL_SHOPS),
  ].join("  ");
  const divider = "-".repeat(header.length);

  const formatRow = (r) => [
    pad(`${r.manufacturer ? r.manufacturer + " " : ""}${r.title}`, COL_TITLE),
    padL(fmt(r.yourPrice), COL_PRICE),
    padL(fmt(r.competitorAvg), COL_AVG),
    padL(fmt(r.competitorLow), COL_AVG),
    padL(fmt(r.diffEur), COL_DIFF),
    padL(fmtPct(r.diffPct), COL_DIFF),
    padL(r.sampledShops, COL_SHOPS),
  ].join("  ");

  console.log(`\n${"=".repeat(header.length)}`);
  console.log(`PRICE ANALYSIS  —  Report: ${generatedAt}`);
  console.log(`Products with data: ${withData.length}/${allResults.length}  |  Min shops: ${MIN_SHOPS}  |  Threshold: ±${THRESHOLD_PCT}%`);
  console.log("=".repeat(header.length));

  if (!ONLY_BELOW && above.length) {
    console.log(`\n▲ YOU ARE ABOVE COMPETITOR AVG (>${THRESHOLD_PCT}%)  [${above.length} products]`);
    console.log(divider);
    console.log(header);
    console.log(divider);
    for (const r of above) console.log(formatRow(r));
  }

  if (!ONLY_ABOVE && below.length) {
    console.log(`\n▼ YOU ARE BELOW COMPETITOR AVG (<-${THRESHOLD_PCT}%)  [${below.length} products]`);
    console.log(divider);
    console.log(header);
    console.log(divider);
    for (const r of below) console.log(formatRow(r));
  }

  if (!ONLY_ABOVE && !ONLY_BELOW && near.length) {
    console.log(`\n◆ ON PAR WITH COMPETITOR AVG (±${THRESHOLD_PCT}%)  [${near.length} products]`);
    console.log(divider);
    console.log(header);
    console.log(divider);
    for (const r of near) console.log(formatRow(r));
  }

  // Summary stats
  const avgDiffPct = rows.reduce((s, r) => s + r.diffPct, 0) / rows.length;
  console.log(`\n${"=".repeat(header.length)}`);
  console.log(`SUMMARY`);
  console.log(`  Above avg (>${THRESHOLD_PCT}%):   ${above.length} products  ← you are more expensive`);
  console.log(`  Below avg (<-${THRESHOLD_PCT}%):  ${below.length} products  ← you are cheaper`);
  console.log(`  On par (±${THRESHOLD_PCT}%):      ${near.length} products`);
  console.log(`  Your avg position vs market: ${fmtPct(avgDiffPct)}`);
  console.log("=".repeat(header.length));

  // CSV output
  if (OUTPUT_CSV) {
    const csvLines = [
      toCsvLine([
        "manufacturer", "title", "handle",
        "yourPrice", "competitorLow", "competitorAvg", "competitorHigh",
        "diffEur", "diffPct", "position",
        "sampledShops", "samples",
      ]),
    ];
    for (const r of sorted) {
      const position = r.diffPct > THRESHOLD_PCT ? "above" : r.diffPct < -THRESHOLD_PCT ? "below" : "on_par";
      csvLines.push(toCsvLine([
        r.manufacturer,
        r.title,
        r.handle,
        r.yourPrice.toFixed(2),
        r.competitorLow?.toFixed(2) ?? "",
        r.competitorAvg.toFixed(2),
        r.competitorHigh?.toFixed(2) ?? "",
        r.diffEur.toFixed(2),
        r.diffPct.toFixed(1),
        position,
        r.sampledShops,
        r.samples,
      ]));
    }
    await fs.mkdir("scripts/market", { recursive: true });
    await fs.writeFile(OUTPUT_CSV, `${csvLines.join("\n")}\n`, "utf8");
    console.log(`\n[analyze] CSV written: ${OUTPUT_CSV}`);
  }
};

run().catch((err) => {
  console.error("[analyze] Fatal:", err);
  process.exitCode = 1;
});
